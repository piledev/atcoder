# 181 c dif:274

## 敗因：

1. 2 点を通る直線を求める方程式を知らなかったこと（調べなかったこと）
2. 自作の方程式で`割り算`を使ってしまったこと

# 183 c dif:335

## 敗因：

できたけどハマった部分があったので反省

1. input()から 2 次元配列を作るときに、list() 指定しないと map 型（？）が追加されてしまい使えない

```python
  # NG
    T.append(map(int,input().split()))
  # OK
    T.append(list(map(int,input().split())))
```

```sh
TypeError: 'map' object is not subscriptable
```

2. 再帰処理の初期化が漏れていた。
   訪問済みの記録を持ち回るやり方の場合、確認が完了したら未訪問の状態に戻す必要がある。

```python
    for i in range(len(arrived)) :
        if arrived[i]:
            continue
        else:
  # NG
            arrived[i]=True
            rec(arrived,depth+1,total+int(T[current][i]),i)
  # OK
            arrived[i]=True
            rec(arrived,depth+1,total+int(T[current][i]),i)
            arrived[i]=False # <- を追加
```

# 193 c dif:379

## 敗因

できたけど、危なかったので反省

1. 発想がなかなか出てこなかった
   `1 ~ N のうち、a**b で表現できない数はいくつあるか`という問題。
   `「1 ~ N まで、一つずつ a**b が成立するかどうかを判定していくには」`と考え始めたが、
   正しい発想は`まずは a,b をインクリメントしながら N を超えない範囲でできる a\*\*b を網羅する`

# 177 c dif:386

## 敗因

1. 愚直に計算して TLE してしまう
   TLE しそうな問題は、ノートに数式を書き出してどこをかっこでくくれそうかを確認するとよい

   ```
   # N = 4 , A = [1,2,3,4] のときの計算
   1*2 + 1*3 + 1*4 + 2*3 + 2*4 + 3*4
   = 1*(2+3+4) + 2*(3+4) + 3*(4)
   = 1*(1+1~Nの和) + 2*(2+1~Nの和)+3*(3+1~Nの和)
   ...

   ```

# 175 c dif:417

## 敗因

1. イテレートで解こうとしてしまったこと。
   イテレートが本当に必要かどうか、最初に考える癖をつけたほうがいいかも。

# 195 b dif:483

## 敗因

1. こののパターンの問題の解き方を知らなかったこと
   一から自分で考えて、結果的にロジックが複雑になってしまった。方向性は間違っていなかったが、複雑ゆえにバグが入って wa になってしまった。
   これを防ぐことができるのは、このパターンを知っている人だけだと思う。
2. パターンを知っていたとしても、条件式を思いつけたか？

# 154 d dif:485

できたけどハマった部分があったので反省

## 敗因

1. 最大値の初期化が足りていなかった。
   処理が２段階(0~k までループ、k~n までループ)で、最後に最大値を表示するような問題。最初のループ直後にその時点の最大値を算出しておく必要があったが抜けていた。最大値が最初にあったらどうすんだという話。
   提出するとほとんどが AC,一部が WA だった。そういうときにチェックポイントの引き出しに加えてもいいかも。

2. 問題を誤解していた。
   問題はよく読もう（読んでるけど）

# 178 c dif:653

## 敗因

1. ややこしく書かれた問題をややこしいまま受け取ってしまった

以下の問題文を読み、「数列？全パターンを探索？」と考え始めてしまってはまった。

```
長さ N の整数の列 A であって以下の条件をすべて満たすものはいくつありますか。
- 0≤Ai≤9
- Ai=0 なる i が存在する。
- Ai=9 なる i が存在する。
ただし、答えはとても大きくなる可能性があるので、10**9+7 で割った余りを出力してください。
```

これは要するに、「0 と 9 の両方を含む数列の数は？」と聞かれているに過ぎない。
と気づけばあとは簡単だ。

```
「0 と 9 の両方を含む数列の数」
= 「全パターンの数」- 「0 と 9 の両方を含まない数列の数」
= 「全パターンの数」- （「0 を含まない数列の数」+「9 を含まない数列の数」-「0 と 9 の療法を含む数列の数」）
```

いくつあるか？という問題に対面したら、まずは中身を見ずに数える方法がないか考えてみよう。

# 167 c dif:595

## 敗因

1. `and` と bit 全探索で使用する `&` は違うので注意
