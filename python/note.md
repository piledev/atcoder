# 10 進数の x を n 進数の文字列に変換する方法

```python
def change(x, n):
    ret = ""
    while x > 0:
        ret = str(x%n) + ret
        x = x // n
    return ret
```

# 少数をなるべく使わない方法

小数を使用すると、誤差が発生する可能性があったり、cast の手間が増えたりといいことないので、なるべく少数を使わずに解く方法がないか考えよう。

```python
def divisor_list(x:int):
  i = 1
  divisor = []
  # while i <= int(math.sqrt(x)) とせずに
  while i**2 <= x:
    if x%i==0:
      divisor.append(i)
      if i!=x//i:
        divisor.append(x//i)
  divisor.sort()
  return divisor
```

# 最大公約数と最小公倍数

python では最大公約数を求める関数が標準ライブラリ math にある。最小公倍数を直接出すものはないが、最大公約数を使って算出することができる。

```python
# lcm: least common multiple (=最小公倍数)
def lcm(x,y)
  # gcd: greatest common divisor (=最大公約数)
  return (x*y//math.gcd(x,y))
```

# 数列の計算

愚直に計算して TLE しそうな問題は、ノートに数式を書き出してどこをかっこでくくれそうかを確認するとよい

```
# N = 4 , A = [1,2,3,4] のときの計算
1*2 + 1*3 + 1*4 + 2*3 + 2*4 + 3*4
= 1*(2+3+4) + 2*(3+4) + 3*(4)
= 1*(1+1~Nの和) + 2*(2+1~Nの和)+3*(3+1~Nの和)
...

```

# Python は便利!

## 便利な標準関数

max()も min()も abs()(絶対値) も標準関数。実装する必要がない!

## 配列の初期化も簡単

0 で初期化したいときは `m=[0]*n` で OK

## 配列内の最小値・最大値も簡単

`min(li)` で OK
(※li は list 型の変数)

# 文字列の並び替えは O(N) かかる

例えば文字列の前半と後半を交換するといった作業には実は O(N)かかるので、これを何度もするとすぐに TLE してしまう。
そのため、このような場合は、現在は通常状態なのか、入換状態なのか、というフラグを利用し、それによって処理の内容を切り替える、という方法が良い。

# 条件を満たす最小値や最大値を算出するパターン

解法は決まっている。
`答えの候補となる数について条件を満たすか順に確かめる`
具体的には、1 のときは条件を満たすか？2 のときは？...と進める。

# 最小値と最大値の初期値

いつだってこうしておこう

```python
min_ans = 10**15
max_ans = -10**15
```

# 累積和と区間和

累積和とは`ある数列の1番目からn番目までの区間の和`
区間和とは`ある数列の一部の区間の和`
区間和は累積和と累積和の引き算で算出できる。
例）数列[1,2,3,4,5]がある場合

```
3~5番目の区間和 = 1~5番目の累積和 - 1~2番目の累積和
```

# Python の実行速度

python は遅い。`10^7`は間に合うが`10^8`は確実に間に合わない。でも、`10^8` も pypy3 なら間に合う場合がある。pypy3 は python3 と全く同じ文法だが、C++並に高速で動作する。ただし注意点がある。

1. Python で使えるライブラリの一部は pypy では使えない
   ただし競プロで使うようなものはほとんど使えるのであまり気にしなくて OK
2. pypy のほうが遅くなってしまう処理がいくつかある
   1. 文字列を反転させる処理は python が若干早い
   2. Decimal の計算を誤差なく正確に行うための標準ライブラリは python が 10 倍以上い

# bit 全探索

基本構文

```python
# n 個の組み合わせを全探索する
for i in range(1<<n):
  # 1桁ずつshiftしながら確認する
  for shift in range(n)
    if i>>shift & 1 == 1:
      # やりたい処理を書く
```

# deque の使い方

基本

```python
from collections import deque
s=deque(list(input()))

# 要素の追加
s.appendleft("dequeの左側に要素を追加")
s.append("dequeの右側に要素を追加")

# 複数要素の追加
s.extend(["a","b"])     # [....,"a","b"] になる
s.extendleft(["k","j"]) # ["j","k",....] になる

# 要素の取り出し(取り出した要素は削除される)
s.popleft()
s.pop()

```

# 包除原理

「0 と 9 の両方を含む数列の数」
= 「全体」- 「0 と 9 の両方を含まない数列の数」
= 「全体」- （「0 を含まない数列の数」+「9 を含まない数列の数」-「0 と 9 の療法を含む数列の数」）

# 全探索？と思ったら

まずは、全探索の範囲を特定することから始めよう。範囲が特定できたら TLE しないかどうか計算量を確認しよう。だめなら別の方法を考える。

# 貪欲

後先考えず目の前のベストを尽くすのが貪欲

# 数学的問題

問題をすり替えていくのと、すり替える際に偶数奇数に着目することがコツなのかな？

# Union-Find 木

- Union-Find 木 はグループ管理を木構造で行うデータ構造のこと。
- 以下の 2 点を高速に行うことができることがメリット。
  - 要素 x, y が同じグループに属するかどうかの確認
  - 要素 x, y のグループを併合する
- 二次元配列で後者の併合処理を行うと O(n)、工夫しても O(log n)かかるが、 Union-Find 木なら、O(a(n))!
  - a(n) はアッカーマン関数 A(n,n)の逆関数とやらで相当小さいらしい（log より小さいとか!)
- グループを分割することはできない
- 簡単に言うとグループのリーダーを決めてリーダーが一致するかどうかで同一グループかどうかを確認するような構造。
- AtCoder では Cheatsheet のコピーで対応しよう

# 単調増加するものには二分探索が有効

- 計算量は O(log n)
- 手順
  - 中央値を確認する。
  - お目当てが中央値より大きいかも → 探索範囲を中央値から右端にする
  - お目当てが中央値より小さいかも → 探索範囲を左端から中央値にする

# 再帰の最大深度

- atcoder の python3 の再帰の最大深度は 2000 らしい
- これは自分で深く設定し直すことができる。
- 必要だと思われる深さより深く再設定しよう。
  - 200000 で TLE しないことは確認できている。

```python3
import sys
sys.setrecursionlimit(250000)
```

# 入力をリストに入れるとき

- 例えば a を int のリストにして標準入力値を取り込みたいとき

  ```python3
  a=map(int,input().split())
  ```

  と書いてしまいがちだがこれは間違い。 正しくは、

  ```python3
  a=list(map(int,input().split()))
  ```

  よくやってしまっているから要注意

# `in range(x)` に関するやりがちな誤り

- 0 ~ n まで調べたいなら、`in range(n+1)` な!

# 多項式の割り算（高校数学知識）

- `A(x) = a*x**2 + b*x + c` と `B(x) = d*x + e` という 2 つの多項式がある場合、`A(x)/B(x)`の商は筆算で求められる。

  ```
          y  z    <= Ans. = y*x + z
       __________
  d  e )  a  b  c

  ```

- 例題

  `A(x) = 2*x**3 + 8*x**2 + 14*x + 12`
  `B(x) = x + 2` のとき、
  `A(x)/B(x)` の商は？

  ```
          2  4  6    <= Ans. = 2*x**2 + 4*x + 6
       ---------------
  1  2 )  2  8 14 12
          2  4
          ------------
             4 14
             4  8
             ---------
                6 12
                6 12
                ------
                   0

  ```

# 鳩ノ巣原理

- 鳩の巣が n 個あり、鳩が n+1 羽いるなら、2 羽以上が住む巣が必ず１つ以上ある。
- 無限に調べなきゃいけない？？みたいなときに使い、最大でも n 回調べれば十分、と結論づけることができる。
- [例題](https://atcoder.jp/contests/abc174/tasks/abc174_c)

# 入力文字列を一文字ずつに分割したい

- 迷路系の問題でよくあるこんな入力を二次元配列に格納したいとき

```
...
..#
.#.
```

- 実はこんなに簡単

```py
s=list()
for i in range(h):
  s.append(list(input()))
```

- str を list でキャストしてやればいいだけなのね。
- 参考までに自分がやりがちな間違い

```py
s=list()
for i in range(h):
  s.append(list(map(str,input().split())))
# split()はスペースがないと分割してくれない。
```

# 動的計画法（DP）

- 使い所
  - 各要素について「選ぶ」「選ばない」という選択肢がある。
  - 全探索すると ``2**n` 通りの選択肢を試すことになる。
